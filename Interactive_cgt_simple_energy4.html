<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive CGT Energy System Profit Allocation (4 Players)</title>
    <style>
        /* (Keep existing styles) */
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f4f4f4;
        }
        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            max-width: 1150px; /* Wider for inputs */
            margin: auto;
        }
        h1, h2, h3 {
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 6px; /* Adjust padding for inputs */
            text-align: right; /* Align numbers right */
            vertical-align: middle; /* Align vertically */
        }
        th, td:nth-child(1), td:nth-child(2) {
             text-align: left; /* Align text left for ID, Type */
        }
        th {
            background-color: #e9e9e9;
        }
        td input[type="number"] {
            width: 90%; /* Adjust width as needed */
            padding: 4px;
            border: 1px solid #ccc;
            border-radius: 3px;
            text-align: right; /* Align input text right */
            box-sizing: border-box; /* Include padding/border in width */
            font-size: 0.95em;
        }
        /* Style calculated fields differently? */
        .calculated-value {
            /* background-color: #f8f8f8; */ /* Optional: subtle background */
            font-weight: normal;
        }
        .profit-value {
             font-weight: bold;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px 5px 15px 0; /* Added bottom margin */
            font-size: 1em;
        }
         button.recalculate { /* Style the main recalculate button */
            background-color: #28a745; /* Green */
         }
         button.recalculate:hover {
             background-color: #218838;
         }
        button:hover {
            background-color: #0056b3;
        }
        #results {
            margin-top: 20px;
            background-color: #eef;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #cce;
        }
        pre {
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        .result-section {
            margin-bottom: 20px;
             padding-bottom: 15px;
             border-bottom: 1px dashed #ccc;
        }
         .result-section:last-child {
             border-bottom: none;
             padding-bottom: 0;
         }
        .result-section h3 {
            margin-top: 0;
            color: #0056b3;
            margin-bottom: 10px;
        }
         /* Tooltip styles */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
            border-bottom: 1px dotted black;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 280px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -140px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.9em;
            line-height: 1.3;
        }

         .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #555 transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        .config-section {
            background-color: #f9f9f9;
            border: 1px solid #eee;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        .config-section label {
            margin-right: 10px;
            font-weight: bold;
        }
        .config-section input[type="number"] {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            width: 100px;
        }
         #update-prompt {
            color: #dc3545; /* Bootstrap danger color */
            font-weight: bold;
            margin-top: 10px;
            padding: 10px;
            background-color: #f8d7da; /* Light red */
            border: 1px solid #f5c6cb; /* Red border */
            border-radius: 4px;
            display: none; /* Hidden by default */
         }

    </style>
</head>
<body>
    <div class="container">
        <h1>Interactive Cooperative Game Theory Tool for Energy System (Profit Allocation)</h1>

        <div class="config-section">
             <label for="marketPrice">Market Price (£/MWh):</label>
             <input type="number" id="marketPrice" value="50.00" step="0.01" onchange="handleParamChange()"> <!-- Also trigger param change -->
             <p style="font-size:0.9em; color: #555;">Adjust the market price or any generator parameter in the table below. Changes require recalculation.</p>
             <button onclick="recalculateAllAnalysis()" class="recalculate">Recalculate All Analysis</button>
             <div id="update-prompt">Parameters changed. Click "Recalculate All Analysis" to update results.</div>
        </div>


        <h2>Generator Data & Individual Performance (4 Players)</h2>
        <p style="font-size:0.9em; color: #555;">You can edit the values in the input fields (Max Gen, Cost, Emissions, CO2 Penalty, CF).</p>
        <table id="player-data">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Type</th>
                    <th>Max Gen (MWh)</th>
                    <th>Cost (£/MWh)</th>
                    <th>Emissions (t/MWh)</th>
                    <th>CO2 Penalty (£/t)</th>
                    <th>CF</th>
                    <!-- Calculated columns -->
                    <th>Actual Gen (MWh)</th>
                    <th>Total Cost (£)</th>
                    <th>Total Revenue (£)</th>
                    <th>Individual Profit (£) [v({i})]</th>
                </tr>
            </thead>
            <tbody>
                <!-- Data will be populated by JavaScript -->
            </tbody>
        </table>

        <h2>Cooperative Game Analysis (Profit Allocation)</h2>
        <p>Players cooperate to generate energy and pool profits. The value of a coalition `v(S)` is its total profit based on the current parameters.</p>

        <button onclick="showCharacteristicFunction()">1. Calculate Characteristic Function v(S)</button>
        <button onclick="calculateAndShowShapley()">2. Calculate Shapley Value</button>
        <button onclick="analyzeCore()">3. Analyze Core</button>
        <button onclick="calculateAndShowNucleolus()">4. Calculate Nucleolus (n=3 only)</button>
        <button onclick="calculateAndShowNashBargaining()">5. Calculate Nash Bargaining</button>
        <button onclick="runAll()">Run All Calculations</button> <!-- Kept for convenience -->

        <div id="results">
            <p>Set parameters and Market Price, then click "Recalculate All Analysis" or individual calculation buttons.</p>
        </div>
    </div>

    <script>
        // --- Player Data (Initial Values) ---
        const playersData = [
            { id: 1, type: 'Nuclear', maxGen: 25000, costPerMwh: 10.57838661, emissions: 0,      co2Penalty: 162.62, cf: 0.9 },
            { id: 2, type: 'Wind',    maxGen: 60000, costPerMwh: 7.054794521,  emissions: 0,      co2Penalty: 162.62, cf: 0.5 },
            { id: 3, type: 'PV',      maxGen: 60000, costPerMwh: 4.718417047,  emissions: 0,      co2Penalty: 162.62, cf: 0.15 },
            { id: 4, type: 'Gas-CCS', maxGen: 10000, costPerMwh: 5.16180266,   emissions: 0.032,  co2Penalty: 162.62, cf: 0.92 }
        ];
        const n = playersData.length;

        // --- Global Variables ---
        let players = []; // Holds *calculated* performance { ...playerData, actualGen, totalCost, etc. }
        let marketPrice = 50.00;
        let characteristicFunction = null; // Stores v(S) - invalidated on param change
        let resultsDiv = document.getElementById('results');
        let updatePromptDiv = document.getElementById('update-prompt');
        let dataChanged = false; // Flag to track if parameters changed

        // --- Helper Functions ---
        function updateMarketPriceFromInput() {
             const priceInput = document.getElementById('marketPrice');
             marketPrice = parseFloat(priceInput.value) || 0;
        }

        // Calculates performance for a SINGLE player object (from playersData)
        function calculatePerformance(playerInputData) {
            const actualGen = (playerInputData.maxGen || 0) * (playerInputData.cf || 0);
            const genCost = actualGen * (playerInputData.costPerMwh || 0);
            const emissionCost = actualGen * (playerInputData.emissions || 0) * (playerInputData.co2Penalty || 0);
            const totalCost = genCost + emissionCost;
            const totalRevenue = actualGen * marketPrice; // Use global marketPrice
            const profit = totalRevenue - totalCost;
            // Return a *new* object combining input data and calculated values
            return { ...playerInputData, actualGen, totalCost, totalRevenue, profit };
        }

        // Recalculates performance for ALL players and updates the global 'players' array
        // Uses current 'playersData' and 'marketPrice'
        function calculateAllPlayersPerformance() {
            console.log("Recalculating performance for all players...");
            players = playersData.map(pData => calculatePerformance(pData));
            console.log("Global 'players' array updated:", players);
        }


        function formatCurrency(value) {
            if (typeof value !== 'number' || isNaN(value)) {
                return "N/A";
            }
            const sign = value < 0 ? '-' : '';
            const absValue = Math.abs(value);
            const formatted = absValue.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            return value < 0 ? `<span style="color:red;">${sign}£${formatted}</span>` : `£${formatted}`;
        }

        function formatNumber(value, digits = 2) {
             if (typeof value !== 'number' || isNaN(value)) {
                return "N/A";
            }
            return value.toLocaleString(undefined, { minimumFractionDigits: digits, maximumFractionDigits: digits });
        }

        function formatInputNumber(value, step) {
             if (typeof value !== 'number' || isNaN(value)) return '';
             // Determine decimal places from step attribute if possible
             const stepString = String(step);
             const decimalPlaces = stepString.includes('.') ? stepString.split('.')[1].length : 0;
             return value.toFixed(decimalPlaces);
        }


        function factorial(num) { /* ... (no changes) ... */
            if (num < 0) return -1;
            if (num === 0) return 1;
            let result = 1;
            for (let i = 2; i <= num; i++) {
                result *= i;
            }
            return result;
        }
        function getCoalitions() { /* ... (no changes) ... */
            const subsets = [];
            const numSubsets = 1 << n; // 2^n

            for (let i = 0; i < numSubsets; i++) {
                const subset = [];
                for (let j = 0; j < n; j++) {
                    if ((i >> j) & 1) {
                        subset.push(j);
                    }
                }
                subsets.push(subset);
            }
            return subsets;
        }
        function coalitionToKey(coalition) { /* ... (no changes) ... */
            return coalition.slice().sort((a, b) => a - b).join(',') || 'empty'; // Sort for consistency
        }
        function formatCoalition(coalitionIndices) { /* ... (no changes) ... */
             if (!coalitionIndices || coalitionIndices.length === 0) return '{}';
              // Ensure 'players' array is populated before formatting coalitions in results
             if (players.length !== n) {
                 console.warn("Attempting to format coalition before 'players' array is fully initialized.");
                 calculateAllPlayersPerformance(); // Try to calculate if needed
                 if (players.length !==n) return '{error: players not ready}'; // Still not ready
             }
             const playerIDs = coalitionIndices.map(index => players[index]?.id || '?'); // Use calculated 'players' array safely
             return `{${playerIDs.join(', ')}}`;
        }


        // --- Core Calculation Functions (Mostly Unchanged Logic) ---

        // Calculate v(S) - Now uses the global 'players' array which holds calculated profits
        function calculateV() {
            console.log(`Calculating Characteristic Function v(S) for n=${n} players based on Profit...`);
            // Ensure player profits are up-to-date before calculating v(S)
             // Note: recalculateAllAnalysis() should have already done this. Add a check?
             if (players.length !== n || players.some(p => p.profit === undefined)) {
                 console.warn("Player performance data missing, recalculating...");
                 calculateAllPlayersPerformance();
             }

            characteristicFunction = {};
            const coalitions = getCoalitions();

            coalitions.forEach(coalition => {
                let totalProfit = 0;
                coalition.forEach(playerIndex => {
                     // Use profit from the global 'players' array
                     totalProfit += players[playerIndex]?.profit || 0; // Add safely
                });
                const key = coalitionToKey(coalition);
                characteristicFunction[key] = totalProfit;
            });
             console.log(`Characteristic Function calculated for ${coalitions.length} coalitions.`);
             dataChanged = false; // V has been recalculated based on current data
             updatePromptDiv.style.display = 'none'; // Hide prompt
            return characteristicFunction;
        }

        function calculateShapleyValues() { /* ... (no changes to logic, relies on calculateV) ... */
            if (!characteristicFunction) {
                console.log("v(S) needed for Shapley, calculating...");
                calculateV();
                if (!characteristicFunction) {
                     console.error("Failed to calculate v(S), cannot compute Shapley.");
                     return null;
                }
            }
            // ... rest of Shapley logic ...
             console.log(`Calculating Shapley Values for n=${n} players...`);
             const shapleyValues = Array(n).fill(0);
             const coalitions = getCoalitions();
             const nFactorial = factorial(n);

             if (nFactorial <= 0) {
                 console.error("Cannot calculate Shapley Value: Factorial calculation issue (n might be too large or negative).");
                 return null;
             }

             for (let i = 0; i < n; i++) { // For each player i
                 for (const coalitionS of coalitions) {
                     if (coalitionS.includes(i)) { // If player i is in coalition S
                         const sSize = coalitionS.length;
                         const coalitionS_minus_i = coalitionS.filter(p => p !== i);

                         const keyS = coalitionToKey(coalitionS);
                         const keyS_minus_i = coalitionToKey(coalitionS_minus_i);

                         const vS = characteristicFunction[keyS] ?? 0;
                         const vS_minus_i = characteristicFunction[keyS_minus_i] ?? 0;

                         const marginalContribution = vS - vS_minus_i;
                         const weight = (factorial(sSize - 1) * factorial(n - sSize)) / nFactorial;

                         shapleyValues[i] += weight * marginalContribution;
                     }
                 }
                 console.log(`Shapley Value for Player ${players[i]?.id || i}: ${formatCurrency(shapleyValues[i])}`);
             }
             return shapleyValues;
        }

        function calculateNashBargaining() { /* ... (no changes to logic, relies on calculateV) ... */
            if (!characteristicFunction) {
                 console.log("v(S) needed for Nash Bargaining, calculating...");
                 calculateV();
                 if (!characteristicFunction) {
                      console.error("Failed to calculate v(S), cannot compute Nash Bargaining.");
                      return null;
                 }
             }
             // ... rest of Nash Bargaining logic ...
             console.log(`Calculating Nash Bargaining Solution for n=${n} players...`);

            const v = characteristicFunction;
            const grandCoalitionIndices = [...Array(n).keys()];
            const vNKey = coalitionToKey(grandCoalitionIndices);
            const vN = v[vNKey]; // v(Grand Coalition)

            // Disagreement point d_i = v({i})
            const disagreementPoint = players.map((p, i) => v[coalitionToKey([i])]);
            const sumDisagreement = disagreementPoint.reduce((sum, d) => sum + d, 0);

            const totalSurplus = vN - sumDisagreement;
            console.log(`v(N) = ${formatCurrency(vN)}, Sum d_i = ${formatCurrency(sumDisagreement)}, Total Surplus = ${formatCurrency(totalSurplus)}`);

            if (totalSurplus < -1e-9) {
                console.warn("Warning: Total surplus from cooperation is negative or zero. NBS reverts to disagreement point.");
                return disagreementPoint;
            }
            if (n <= 0) {
                 console.error("Cannot calculate Nash Bargaining: Number of players n must be positive.");
                 return null;
            }

            const nbsAllocation = disagreementPoint.map(d_i => d_i + totalSurplus / n);

            console.log(`NBS Allocation: ${nbsAllocation.map(formatCurrency).join(', ')}`);
            return nbsAllocation;
        }

        function checkCoreConditions(allocation) { /* ... (no changes to logic, relies on calculateV) ... */
             if (!characteristicFunction) {
                 console.log("v(S) needed for Core Check, calculating...");
                 calculateV();
                 if (!characteristicFunction) {
                      console.error("Failed to calculate v(S), cannot check Core conditions.");
                      return { satisfied: false, messages: ["Cannot check Core: Characteristic function v(S) failed to calculate."] };
                 }
             }
              // ... rest of Core Check logic ...
              if (!allocation || allocation.length !== n) return { satisfied: false, messages: ["Invalid allocation provided."] };

            const v = characteristicFunction;
            const coalitions = getCoalitions();
            const grandCoalitionKey = coalitionToKey([...Array(n).keys()]);
            const vN = v[grandCoalitionKey];
            const totalAllocation = allocation.reduce((sum, x) => sum + x, 0);

            let messages = [];
            let conditionsMet = true;
            const tolerance = 1e-6;

            // 1. Efficiency Check: sum(x_i) = v(N)
            if (Math.abs(totalAllocation - vN) > tolerance) {
                 messages.push(`Efficiency Condition FAILED: Sum of allocation (${formatCurrency(totalAllocation)}) != v(N) (${formatCurrency(vN)})`);
                 conditionsMet = false;
            } else {
                 messages.push(`Efficiency Condition MET: Sum of allocation (${formatCurrency(totalAllocation)}) ≈ v(N) (${formatCurrency(vN)})`);
            }

             // 2. Individual & Group Rationality: sum(x_i for i in S) >= v(S) for all S
             coalitions.forEach(coalitionS => {
                if (coalitionS.length > 0 && coalitionS.length < n) { // Exclude empty set and grand coalition
                    const keyS = coalitionToKey(coalitionS);
                    const vS = v[keyS];
                    const sumAllocationS = coalitionS.reduce((sum, i) => sum + allocation[i], 0);

                    if (sumAllocationS < vS - tolerance) {
                        messages.push(`Rationality FAILED for coalition ${formatCoalition(coalitionS)}: Sum Alloc(S) = ${formatCurrency(sumAllocationS)} < v(S) = ${formatCurrency(vS)} (Coalition has incentive to leave)`);
                        conditionsMet = false;
                    }
                }
             });

             if (conditionsMet && messages.length <= 1) {
                 messages.push(`All Individual and Group Rationality conditions MET.`);
             } else if (conditionsMet) {
                  let rationalityFailed = messages.some(m => m.includes("FAILED for coalition"));
                  if (!rationalityFailed) {
                      messages.push(`All Individual and Group Rationality conditions MET.`);
                  }
             } else if (!conditionsMet && messages.length > 1) {
                  messages.push(`At least one Rationality condition FAILED.`);
             }


             return { satisfied: conditionsMet, messages: messages };
        }
        function getCoreDescription() { /* ... (no changes to logic, relies on calculateV) ... */
             if (!characteristicFunction) {
                 console.log("v(S) needed for Core Description, calculating...");
                 calculateV();
                 if (!characteristicFunction) {
                      console.error("Failed to calculate v(S), cannot describe Core.");
                      return '<div class="result-section"><h3>Core Analysis</h3><p style="color:red;">Error calculating characteristic function, cannot describe Core.</p></div>';
                 }
             }
             // ... rest of Core Description logic ...
             const v = characteristicFunction;
            const grandCoalitionIndices = [...Array(n).keys()];
            const vNKey = coalitionToKey(grandCoalitionIndices);
            const vN = v[vNKey];

            let description = `<div class="result-section"><h3><span class="tooltip">Core Analysis<span class="tooltiptext">The set of profit allocations that are 'stable'. No player or subgroup of players (coalition) has an incentive to break away from the grand coalition N, because they receive at least as much profit (x(S)) within N as they could get on their own (v(S)). The allocation must also be efficient (sum(xi)=v(N)).</span></span> (n=${n})</h3>`;

            description += `<p>The Core is the set of profit allocations (x1, ..., x${n}) such that:</p><ul>`;
            description += `<li>Sum(xi) = v(N) = ${formatCurrency(vN)} (Efficiency)</li>`;
            players.forEach((p, i) => {
                const v_i = v[coalitionToKey([i])];
                description += `<li>x${p.id} ≥ v({${p.id}}) = ${formatCurrency(v_i)}</li>`;
            });
            description += `<li>Sum(xi for i in S) ≥ v(S) for all other coalitions S ⊂ N, S ≠ ∅</li></ul>`;

            if (n === 3) {
                 // ... (n=3 specific details) ...
                const v1 = v['0']; const v2 = v['1']; const v3 = v['2'];
                const v12 = v['0,1']; const v13 = v['0,2']; const v23 = v['1,2'];
                const v123 = vN;

                description += `<p>For n=3, the explicit group rationality conditions are:</p><ul>`;
                description += `<li>x1 + x2 ≥ v({1,2}) = ${formatCurrency(v12)}</li>`;
                description += `<li>x1 + x3 ≥ v({1,3}) = ${formatCurrency(v13)}</li>`;
                description += `<li>x2 + x3 ≥ v({2,3}) = ${formatCurrency(v23)}</li></ul>`;

                let coreNonEmpty = true;
                let reasons = [];
                const tolerance = 1e-6;
                if (v123 < v1 + v2 + v3 - tolerance) { coreNonEmpty = false; reasons.push(`v(N) < v(1)+v(2)+v(3)`); }
                if (v123 < v12 + v3 - tolerance) { coreNonEmpty = false; reasons.push(`v(N) < v(12)+v(3)`); }
                if (v123 < v13 + v2 - tolerance) { coreNonEmpty = false; reasons.push(`v(N) < v(13)+v(2)`); }
                if (v123 < v23 + v1 - tolerance) { coreNonEmpty = false; reasons.push(`v(N) < v(23)+v(1)`); }
                if (2 * v123 < v12 + v13 + v23 - tolerance) { coreNonEmpty = false; reasons.push(`2*v(N) < v(12)+v(13)+v(23)`); }

                if (coreNonEmpty) {
                    description += "<p style='color: green;'><b>The Core appears to be non-empty for n=3.</b> (Necessary conditions met).</p>";
                    description += "<p>Implied bounds from inequalities:</p><ul>";
                    description += `<li>${formatCurrency(v1)} ≤ x1 ≤ ${formatCurrency(v123 - v23)}</li>`;
                    description += `<li>${formatCurrency(v2)} ≤ x2 ≤ ${formatCurrency(v123 - v13)}</li>`;
                    description += `<li>${formatCurrency(v3)} ≤ x3 ≤ ${formatCurrency(v123 - v12)}</li>`;
                    description += "</ul><p>The actual core is a geometric shape (polytope) within these bounds satisfying all conditions simultaneously.</p>"
                } else {
                    description += `<p style="color: red;"><b>The Core is likely EMPTY for n=3.</b> Stability condition(s) not met: ${reasons.join('; ')}</p>`;
                }
            } else {
                 description += "<p>Checking for non-emptiness (balancedness) and describing the geometric shape of the Core is complex for n > 3 and not implemented here.</p>";
                 description += "<p>You can check if specific allocation methods (like Shapley, Nucleolus, Nash) result in an allocation that lies *within* the Core using the 'Core Check' provided with their results.</p>";
            }
            description += `</div>`;
            return description;
        }
        function calculateNucleolusN3() { /* ... (no changes to logic, relies on calculateV) ... */
             if (n !== 3) {
                 console.warn(`Nucleolus calculation skipped: Implementation is only for n=3 (current n=${n}).`);
                 return null;
             }
             if (!characteristicFunction) {
                  console.log("v(S) needed for Nucleolus, calculating...");
                  calculateV();
                  if (!characteristicFunction) {
                       console.error("Failed to calculate v(S), cannot compute Nucleolus.");
                       return null;
                  }
             }
              // ... rest of Nucleolus (n=3) logic ...
             console.log("Calculating Nucleolus (n=3 only) based on profit v(S)...");

             const v = characteristicFunction;
             const v1 = v['0'] || 0; const v2 = v['1'] || 0; const v3 = v['2'] || 0;
             const v12 = v['0,1'] || 0; const v13 = v['0,2'] || 0; const v23 = v['1,2'] || 0;
             const v123 = v['0,1,2'] || 0;

             let candidates = [];
             const tolerance = 1e-9;

             try {
                 // C1: e({1})=e({2})=e({3})
                 let x1_c1 = (v123 + 2*v1 - v2 - v3) / 3;
                 let x2_c1 = x1_c1 + v2 - v1;
                 let x3_c1 = x1_c1 + v3 - v1;
                 if (isValidAllocation([x1_c1, x2_c1, x3_c1], v123)) candidates.push([x1_c1, x2_c1, x3_c1]);

                 // C2: e({1,2})=e({3}), e({1,3})=e({2}), e({2,3})=e({1}) (Pair/Singleton)
                 let x3_c2a = (v123 + v3 - v12) / 2;
                 let x2_c2a = (v123 + v2 - v13) / 2;
                 let x1_c2a = v123 - x2_c2a - x3_c2a;
                  if (isValidAllocation([x1_c2a, x2_c2a, x3_c2a], v123)) candidates.push([x1_c2a, x2_c2a, x3_c2a]);

                 let x1_c2b = (v123 + v1 - v23) / 2;
                 let x3_c2b = (v123 + v3 - v12) / 2; // Same as x3_c2a
                 let x2_c2b = v123 - x1_c2b - x3_c2b;
                  if (isValidAllocation([x1_c2b, x2_c2b, x3_c2b], v123)) candidates.push([x1_c2b, x2_c2b, x3_c2b]);

                 let x2_c2c = (v123 + v2 - v13) / 2; // Same as x2_c2a
                 let x1_c2c = (v123 + v1 - v23) / 2; // Same as x1_c2b
                 let x3_c2c = v123 - x1_c2c - x2_c2c;
                  if (isValidAllocation([x1_c2c, x2_c2c, x3_c2c], v123)) candidates.push([x1_c2c, x2_c2c, x3_c2c]);

                 // C3: e({1,2})=e({1,3})=e({2,3})
                 let x3_c3 = (v123 + v13 + v23 - 2 * v12) / 3;
                 let x2_c3 = x3_c3 - (v13 - v12);
                 let x1_c3 = x3_c3 - (v23 - v12);
                 if (isValidAllocation([x1_c3, x2_c3, x3_c3], v123)) candidates.push([x1_c3, x2_c3, x3_c3]);

             } catch(e) {
                  console.error("Error calculating nucleolus candidates:", e);
             }

             const shapleyCand = calculateShapleyValues();
             if (shapleyCand && isValidAllocation(shapleyCand, v123)) {
                 candidates.push(shapleyCand);
             }
             const nbsCand = calculateNashBargaining();
             if (nbsCand && isValidAllocation(nbsCand, v123)) {
                  candidates.push(nbsCand);
             }

             const uniqueCandidates = [];
             const seenKeys = new Set();
             candidates.forEach(cand => {
                 if (isValidAllocation(cand, v123)) {
                     const key = cand.map(x => x.toFixed(8)).join(',');
                     if (!seenKeys.has(key)) {
                         uniqueCandidates.push(cand);
                         seenKeys.add(key);
                     }
                 }
             });
             console.log("Unique candidates for Nucleolus (n=3):", uniqueCandidates.length);


             let bestNucleolus = null;
             let minLexExcessVector = null;
             const coalitionsForExcess = getCoalitions().filter(c => c.length > 0 && c.length < n);

             uniqueCandidates.forEach(cand => {
                  let excesses = [];
                  coalitionsForExcess.forEach(coalitionS => {
                      const keyS = coalitionToKey(coalitionS);
                      const vS = v[keyS] || 0;
                      const sumAllocationS = coalitionS.reduce((sum, i) => sum + cand[i], 0);
                      excesses.push(vS - sumAllocationS);
                  });
                  excesses.sort((a, b) => b - a);

                  if (bestNucleolus === null || isLexicographicallySmaller(excesses, minLexExcessVector)) {
                      minLexExcessVector = excesses;
                      bestNucleolus = cand;
                  }
             });

             if (!bestNucleolus) {
                  console.error("Could not determine Nucleolus from candidates for n=3.");
                  const coreCheckShapley = checkCoreConditions(shapleyCand);
                  if(shapleyCand && coreCheckShapley.satisfied) return shapleyCand;
                  return null;
             }

             console.log("Final Nucleolus (n=3):", bestNucleolus.map(x=>x.toFixed(2)));
             return bestNucleolus;
        }
        function isValidAllocation(alloc, expectedSum = null) { /* ... (no changes) ... */
             if (!alloc || !Array.isArray(alloc) || alloc.length !== n) {
                 return false;
             }
             if (alloc.some(x => typeof x !== 'number' || isNaN(x))) {
                 return false;
             }

             if (expectedSum !== null && typeof expectedSum === 'number' && !isNaN(expectedSum)) {
                 const sum = alloc.reduce((a, b) => a + b, 0);
                 // Increased tolerance slightly for sums involving many floats
                 if (Math.abs(sum - expectedSum) > 1e-5) {
                      console.warn("isValidAllocation: Allocation does not sum to expected value:", alloc, "Sum:", sum.toFixed(4), "Expected:", expectedSum.toFixed(4));
                      return false;
                 }
             }
             return true;
        }
        function isLexicographicallySmaller(vecA, vecB) { /* ... (no changes) ... */
             const len = Math.min(vecA.length, vecB.length);
             for (let i = 0; i < len; i++) {
                 if (vecA[i] < vecB[i] - 1e-9) return true;
                 if (vecA[i] > vecB[i] + 1e-9) return false;
             }
             return vecA.length < vecB.length;
        }

        // --- UI Functions ---

        // Populates table with INPUT fields for parameters
        function populateTable() {
            const tbody = document.getElementById('player-data').querySelector('tbody');
            tbody.innerHTML = ''; // Clear existing rows
            // Initial calculation of performance for display
            calculateAllPlayersPerformance();

            playersData.forEach((pData, index) => {
                 // Get the calculated performance for this player
                const pCalc = players[index]; // Should correspond based on index

                // Define steps for input fields
                const steps = { maxGen: 1, costPerMwh: 0.01, emissions: 0.001, co2Penalty: 0.01, cf: 0.01 };

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${pData.id}</td>
                    <td>${pData.type}</td>
                    <td><input type="number" value="${pData.maxGen}" step="${steps.maxGen}" data-player-index="${index}" data-param="maxGen" onchange="handleParamChange(event)"></td>
                    <td><input type="number" value="${pData.costPerMwh}" step="${steps.costPerMwh}" data-player-index="${index}" data-param="costPerMwh" onchange="handleParamChange(event)"></td>
                    <td><input type="number" value="${pData.emissions}" step="${steps.emissions}" min="0" data-player-index="${index}" data-param="emissions" onchange="handleParamChange(event)"></td>
                    <td><input type="number" value="${pData.co2Penalty}" step="${steps.co2Penalty}" min="0" data-player-index="${index}" data-param="co2Penalty" onchange="handleParamChange(event)"></td>
                    <td><input type="number" value="${pData.cf}" step="${steps.cf}" min="0" max="1" data-player-index="${index}" data-param="cf" onchange="handleParamChange(event)"></td>
                    <!-- Calculated values - give them IDs -->
                    <td id="actualGen-${pData.id}" class="calculated-value">${formatNumber(pCalc.actualGen, 0)}</td>
                    <td id="totalCost-${pData.id}" class="calculated-value">${formatCurrency(pCalc.totalCost)}</td>
                    <td id="totalRevenue-${pData.id}" class="calculated-value">${formatCurrency(pCalc.totalRevenue)}</td>
                    <td id="profit-${pData.id}" class="profit-value">${formatCurrency(pCalc.profit)}</td>
                `;
                tbody.appendChild(row);
            });
        }

         // Handles changes in the table input fields or market price
        function handleParamChange(event = null) {
             dataChanged = true; // Mark that data has changed
             characteristicFunction = null; // Invalidate v(S)
             resultsDiv.innerHTML = '<p>Parameters changed. Recalculate analysis.</p>'; // Clear old results
             updatePromptDiv.style.display = 'block'; // Show prompt

             if (event && event.target.id === 'marketPrice') {
                 // Market price changed - update it
                 updateMarketPriceFromInput();
                 // Recalculate all player performances as price affects everyone
                 calculateAllPlayersPerformance();
                 // Update all calculated cells in the table
                 updateTableCalculatedCells();
                 console.log("Market price changed. Recalculated all player performance.");

             } else if (event && event.target.dataset.playerIndex !== undefined) {
                 // A generator parameter changed
                 const inputElement = event.target;
                 const playerIndex = parseInt(inputElement.dataset.playerIndex, 10);
                 const param = inputElement.dataset.param;
                 const newValue = parseFloat(inputElement.value);

                 if (!isNaN(newValue) && playerIndex >= 0 && playerIndex < playersData.length && playersData[playerIndex].hasOwnProperty(param)) {
                     // Update the source data array
                     playersData[playerIndex][param] = newValue;
                     console.log(`Updated playersData[${playerIndex}].${param} to ${newValue}`);

                     // Recalculate performance for the *affected* player
                     const updatedPlayerPerformance = calculatePerformance(playersData[playerIndex]);

                     // Update the global 'players' array
                     players[playerIndex] = updatedPlayerPerformance;

                     // Update the calculated cells *only for this player's row*
                     updateTableRowCalculatedCells(playerIndex);
                     console.log(`Recalculated performance and updated table row for player index ${playerIndex}`);

                 } else {
                     console.error("Invalid parameter change event:", event);
                     // Optional: Add visual feedback for invalid input
                 }
             } else {
                  // If called without event (e.g., initial load or programmatic change)
                  // ensure price is read and recalculate all
                  updateMarketPriceFromInput();
                  calculateAllPlayersPerformance();
                  updateTableCalculatedCells();
             }
        }

         // Updates the calculated columns for a specific row in the table
         function updateTableRowCalculatedCells(playerIndex) {
             const pCalc = players[playerIndex];
             if (!pCalc) return; // Safety check

             document.getElementById(`actualGen-${pCalc.id}`).innerHTML = formatNumber(pCalc.actualGen, 0);
             document.getElementById(`totalCost-${pCalc.id}`).innerHTML = formatCurrency(pCalc.totalCost);
             document.getElementById(`totalRevenue-${pCalc.id}`).innerHTML = formatCurrency(pCalc.totalRevenue);
             document.getElementById(`profit-${pCalc.id}`).innerHTML = formatCurrency(pCalc.profit);
         }

         // Updates the calculated columns for ALL rows in the table
         function updateTableCalculatedCells() {
             players.forEach((pCalc, index) => {
                 updateTableRowCalculatedCells(index);
             });
         }


        function displayResultsHeader(title) { /* ... (no changes) ... */
             resultsDiv.innerHTML += `<div class="result-section"><h3>${title}</h3></div>`;
        }
        function appendToLastResultSection(htmlContent) { /* ... (no changes) ... */
             const sections = resultsDiv.getElementsByClassName('result-section');
             if (sections.length > 0) {
                 sections[sections.length - 1].innerHTML += htmlContent;
             } else {
                 resultsDiv.innerHTML += `<div class="result-section">${htmlContent}</div>`;
             }
        }
        function displayCharacteristicFunction() { /* ... (no changes) ... */
            let html = `<p><span class="tooltip">Value v(S)<span class="tooltiptext">The total profit generated by the members of coalition S operating together. Higher profit is better. v(N) is the total profit of the grand coalition.</span></span> for each coalition S:</p><ul>`;
            const coalitions = getCoalitions();
            coalitions.sort((a, b) => {
                if (a.length !== b.length) return a.length - b.length;
                return coalitionToKey(a).localeCompare(coalitionToKey(b));
            });
            coalitions.forEach(coalition => {
                 const key = coalitionToKey(coalition);
                 const value = characteristicFunction[key];
                 const formattedValue = (typeof value === 'number' && !isNaN(value)) ? formatCurrency(value) : 'N/A';
                 html += `<li>v(${formatCoalition(coalition)}) = ${formattedValue}</li>`;
            });
            html += `</ul>`;
            appendToLastResultSection(html);
        }
        function displayAllocationResults(title, allocation, tooltipText) { /* ... (no changes) ... */
             let html = `<p>Allocation based on <span class="tooltip">${title}<span class="tooltiptext">${tooltipText}</span></span>:</p>`;
             if (!isValidAllocation(allocation)) {
                  html += `<p style="color:red;">Error: Invalid allocation data received.</p>`;
                  appendToLastResultSection(html);
                  return;
             }
             html += `<ul>`;
             let totalAllocated = 0;
             allocation.forEach((value, index) => {
                if (index < players.length) {
                    html += `<li>Player ${players[index].id} (${players[index].type}): ${formatCurrency(value)}</li>`;
                    if (typeof value === 'number' && !isNaN(value)) {
                        totalAllocated += value;
                    }
                } else {
                     html += `<li>Invalid player index ${index}: ${formatCurrency(value)}</li>`;
                }
             });
             html += `</ul>`;
             html += `<p>Total Allocated Profit: ${formatCurrency(totalAllocated)}</p>`;
             const coreCheck = checkCoreConditions(allocation);
             html += `<h4>Core Check for this Allocation:</h4>`;
             if (coreCheck.satisfied) {
                 html += `<p style="color: green;"><b>This allocation IS in the Core.</b> It is stable.</p>`;
             } else {
                 html += `<p style="color: red;"><b>This allocation is NOT in the Core.</b></p>`;
                 html += `<ul>`;
                 coreCheck.messages.forEach(msg => html += `<li>${msg}</li>`);
                 html += `</ul>`;
             }
             appendToLastResultSection(html);
        }

        // --- Button Click Handlers ---

        // Central function to recalculate everything after parameter changes
        function recalculateAllAnalysis() {
             console.clear();
             resultsDiv.innerHTML = '<p>Recalculating all analysis based on current parameters...</p>';
             console.log("Starting full recalculation...");

             // 1. Ensure Market Price is current
             updateMarketPriceFromInput();
             console.log("Market Price:", marketPrice);

             // 2. Ensure all player performances are recalculated based on current playersData & marketPrice
             calculateAllPlayersPerformance();

             // 3. Update all calculated cells in the table display
             updateTableCalculatedCells();
             console.log("Table display updated.");

             // 4. Reset and Recalculate Characteristic Function
             // calculateV() will be called implicitly by runAll's component functions if needed,
             // or we can call it explicitly here. Let's call it to ensure it's done first.
             calculateV();
             if (!characteristicFunction) {
                 resultsDiv.innerHTML = '<p style="color:red;">Error calculating characteristic function after parameter update. Cannot proceed.</p>';
                 return;
             }
             console.log("Characteristic function recalculated.");
             dataChanged = false; // Reset flag
             updatePromptDiv.style.display = 'none'; // Hide prompt

             // 5. Run and display all subsequent analyses
             runAllDisplay(); // Renamed runAll to avoid conflict, this focuses on display
             console.log("All analyses run and displayed.");
        }


        function showCharacteristicFunction() {
             if (dataChanged) {
                 resultsDiv.innerHTML = '<p style="color:orange;">Parameters have changed. Please click "Recalculate All Analysis" first.</p>';
                 return;
             }
             resultsDiv.innerHTML = '';
             displayResultsHeader("Characteristic Function v(S)");
             if (!characteristicFunction) calculateV(); // Calculate if missing
             if (characteristicFunction) {
                displayCharacteristicFunction();
             } else {
                 appendToLastResultSection('<p style="color:red;">Error calculating characteristic function.</p>');
             }
        }

        function calculateAndShowShapley() {
             if (dataChanged) {
                 resultsDiv.innerHTML = '<p style="color:orange;">Parameters have changed. Please click "Recalculate All Analysis" first.</p>';
                 return;
             }
             resultsDiv.innerHTML = '';
             displayResultsHeader("Shapley Value");
             const shapley = calculateShapleyValues(); // Will trigger calculateV if needed
             if (shapley && isValidAllocation(shapley)) {
                displayAllocationResults("Shapley Value", shapley, "A fair allocation distributing the total profit v(N) based on players' average marginal contributions to the profit of all possible coalitions.");
             } else {
                 appendToLastResultSection('<p style="color:red;">Error calculating Shapley values.</p>');
             }
        }

         function analyzeCore() {
             if (dataChanged) {
                 resultsDiv.innerHTML = '<p style="color:orange;">Parameters have changed. Please click "Recalculate All Analysis" first.</p>';
                 return;
             }
             resultsDiv.innerHTML = '';
             const coreDescHtml = getCoreDescription(); // Will trigger calculateV if needed
             resultsDiv.innerHTML = coreDescHtml;
         }

         function calculateAndShowNucleolus() {
             if (dataChanged) {
                 resultsDiv.innerHTML = '<p style="color:orange;">Parameters have changed. Please click "Recalculate All Analysis" first.</p>';
                 return;
             }
             resultsDiv.innerHTML = '';
             displayResultsHeader("Nucleolus");
              if (n !== 3) {
                 appendToLastResultSection(`<p style="color:orange;">Nucleolus calculation via excess equalization is only implemented for n=3 players (current n=${n}).</p>`);
                 return;
             }
             const nucleolus = calculateNucleolusN3(); // Will trigger calculateV if needed
             if (nucleolus && isValidAllocation(nucleolus)) {
                 displayAllocationResults("Nucleolus", nucleolus, "An allocation that aims to minimize the 'unhappiness' (excess = v(S)-x(S)) of the most unhappy coalition. Always in the Core if the Core is non-empty.");
             } else {
                 appendToLastResultSection('<p style="color:orange;">Could not determine a valid Nucleolus allocation (or n != 3).</p>');
             }
         }

         function calculateAndShowNashBargaining() {
             if (dataChanged) {
                 resultsDiv.innerHTML = '<p style="color:orange;">Parameters have changed. Please click "Recalculate All Analysis" first.</p>';
                 return;
             }
            resultsDiv.innerHTML = '';
            displayResultsHeader("Nash Bargaining Solution");
             const nbs = calculateNashBargaining(); // Will trigger calculateV if needed
             if (nbs && isValidAllocation(nbs)) {
                 displayAllocationResults("Nash Bargaining Solution", nbs, "An allocation maximizing the product of players' gains relative to a 'disagreement point' (individual profits v({i})). Splits surplus equally over disagreement payoffs.");
             } else {
                appendToLastResultSection('<p style="color:red;">Error calculating Nash Bargaining Solution.</p>');
             }
         }

         // This version just runs the display logic, assuming data is current
        function runAllDisplay() {
            resultsDiv.innerHTML = ''; // Clear previous results

            if (!characteristicFunction) {
                 resultsDiv.innerHTML = '<p style="color:red;">Characteristic function is not available. Recalculation needed.</p>';
                 return;
            }

            // 1. Characteristic Function
            displayResultsHeader("1. Characteristic Function v(S)");
            displayCharacteristicFunction();

            // 2. Shapley Value
            displayResultsHeader("2. Shapley Value");
            const shapley = calculateShapleyValues(); // Use already calc'd v(S)
             if (shapley && isValidAllocation(shapley)) {
                displayAllocationResults("Shapley Value", shapley, "Fair allocation based on average marginal contributions.");
             } else { appendToLastResultSection('<p style="color:red;">Could not calculate/display Shapley.</p>');}

            // 3. Core Analysis
            resultsDiv.innerHTML += getCoreDescription(); // Use already calc'd v(S)

            // 4. Nucleolus (for n=3)
             displayResultsHeader("4. Nucleolus");
             if (n === 3) {
                const nucleolus = calculateNucleolusN3(); // Use already calc'd v(S)
                 if (nucleolus && isValidAllocation(nucleolus)) {
                     displayAllocationResults("Nucleolus", nucleolus, "Minimizes maximum coalition unhappiness. In Core if non-empty.");
                 } else {
                     appendToLastResultSection('<p style="color:orange;">Could not determine valid Nucleolus.</p>');
                 }
             } else {
                 appendToLastResultSection(`<p style="color:orange;">Nucleolus calculation only implemented for n=3 (current n=${n}).</p>`);
             }

            // 5. Nash Bargaining
            displayResultsHeader("5. Nash Bargaining Solution");
            const nbs = calculateNashBargaining(); // Use already calc'd v(S)
            if (nbs && isValidAllocation(nbs)) {
                displayAllocationResults("Nash Bargaining Solution", nbs, "Splits surplus equally over individual profits.");
            } else { appendToLastResultSection('<p style="color:red;">Could not calculate/display Nash Bargaining Solution.</p>'); }
        }

        // Legacy function name kept for button compatibility - just calls the main recalculate
        function runAll() {
            recalculateAllAnalysis();
        }


        // --- Initial Setup ---
        window.onload = () => {
            document.getElementById('marketPrice').value = marketPrice.toFixed(2);
            populateTable(); // Create interactive table and calculate initial performance
            dataChanged = false; // Start with data consistent
            updatePromptDiv.style.display = 'none'; // Hide prompt initially
             resultsDiv.innerHTML = `<p>Generator data and individual performance loaded for ${n} players. Parameters are now interactive.</p>
             <p><i>Change Market Price or table values, then click <b>"Recalculate All Analysis"</b> to update the CGT results.</i></p>
             <p>Tooltips (<span class="tooltip">like this<span class="tooltiptext">Hover over dotted underlined text for explanations.</span></span>) provide definitions.</p>
             <p style="color: #555;">Note: Core analysis provides general definitions for n=${n}. Nucleolus calculation is only available for n=3.</p>`;
        };

    </script>
</body>
</html>